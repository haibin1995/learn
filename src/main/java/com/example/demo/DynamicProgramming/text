动态规划是一种编程原理，可以通过将非常复杂的问题划分为更小的子问题来解决。这个原则与递归很类似，但是与递归有一个关键点的不同，就是每个不同的子问题只能被解决一次。

为了理解动态规划，我们首先需要理解递归关系的问题。每个单独的复杂问题可以被划分为很小的子问题，这表示我们可以在这些问题之间构造一个递归关系。
让我们来看一个我们所熟悉的例子：斐波拉契数列，斐波拉契数列的定义具有以下的递归关系：

注意：递归关系是递归地定义下一项是先前项的函数的序列的等式。Fibonacci序列就是一个很好的例子。

所以，如果我们想要找到斐波拉契数列序列中的第n个数，我们必须知道序列中第n个前面的两个数字。

但是，每次我们想要计算Fibonacci序列的不同元素时，我们在递归调用中都有一些重复调用

例如：如果我们想计算F(5),明显的我们需要计算F(3)和F(4)作为计算F(5)的先决条件。然而，为了计算F(4)，我们需要计算F(3)和F(2)，因此我们又需要计算F(2)和F(1)来得到F(3)，其他的求解诸如此类。

这样的话就会导致很多重复的计算，这些重复计算本质上是冗余的，并且明显的减慢了算法的效率。为了解决这种问题，我们介绍动态规划。

在这种方法中，我们对解决方案进行建模，就像我们要递归地解决它一样，但我们从头开始解决它，将解决方案记忆到我们到达顶部的子问题（步骤）。
因此，对于Fibonacci序列，我们首先求解并记忆F（1）和F（2），然后使用两个记忆步骤计算F（3），依此类推。这意味着序列中每个单独元素的计算都是O（1），因为我们已经知道前两个元素。

当使用动态规划解决问题的时候，我们一般会采用下面三个步骤：

确定适用于所述问题的递归关系
初始化内存、数组、矩阵的初始值
确保当我们进行递归调用（可以访问子问题的答案）的时候它总是被提前解决。